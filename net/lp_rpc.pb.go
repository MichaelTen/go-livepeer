// Code generated by protoc-gen-go. DO NOT EDIT.
// source: net/lp_rpc.proto

package net

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// This request is sent by the broadcaster in `GetTranscoder` to request
// information on which transcoder to use.
type TranscoderRequest struct {
	// ID of the job that the broadcaster needs a transcoder for
	JobId int64 `protobuf:"varint,1,opt,name=jobId,proto3" json:"jobId,omitempty"`
	// Broadcaster's signature over the jobId
	Sig                  []byte   `protobuf:"bytes,2,opt,name=sig,proto3" json:"sig,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TranscoderRequest) Reset()         { *m = TranscoderRequest{} }
func (m *TranscoderRequest) String() string { return proto.CompactTextString(m) }
func (*TranscoderRequest) ProtoMessage()    {}
func (*TranscoderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_lp_rpc_410c4c5f0e477d83, []int{0}
}
func (m *TranscoderRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TranscoderRequest.Unmarshal(m, b)
}
func (m *TranscoderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TranscoderRequest.Marshal(b, m, deterministic)
}
func (dst *TranscoderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TranscoderRequest.Merge(dst, src)
}
func (m *TranscoderRequest) XXX_Size() int {
	return xxx_messageInfo_TranscoderRequest.Size(m)
}
func (m *TranscoderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TranscoderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TranscoderRequest proto.InternalMessageInfo

func (m *TranscoderRequest) GetJobId() int64 {
	if m != nil {
		return m.JobId
	}
	return 0
}

func (m *TranscoderRequest) GetSig() []byte {
	if m != nil {
		return m.Sig
	}
	return nil
}

//
// OSInfo needed to negotiate storages that will be used.
// It carries info needed to write to the storage.
type OSInfo struct {
	// Storage type: s3, ipfs.
	Storage              string    `protobuf:"bytes,1,opt,name=storage,proto3" json:"storage,omitempty"`
	S3Info               *S3OSInfo `protobuf:"bytes,16,opt,name=s3info,proto3" json:"s3info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *OSInfo) Reset()         { *m = OSInfo{} }
func (m *OSInfo) String() string { return proto.CompactTextString(m) }
func (*OSInfo) ProtoMessage()    {}
func (*OSInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_lp_rpc_410c4c5f0e477d83, []int{1}
}
func (m *OSInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OSInfo.Unmarshal(m, b)
}
func (m *OSInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OSInfo.Marshal(b, m, deterministic)
}
func (dst *OSInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OSInfo.Merge(dst, src)
}
func (m *OSInfo) XXX_Size() int {
	return xxx_messageInfo_OSInfo.Size(m)
}
func (m *OSInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_OSInfo.DiscardUnknown(m)
}

var xxx_messageInfo_OSInfo proto.InternalMessageInfo

func (m *OSInfo) GetStorage() string {
	if m != nil {
		return m.Storage
	}
	return ""
}

func (m *OSInfo) GetS3Info() *S3OSInfo {
	if m != nil {
		return m.S3Info
	}
	return nil
}

type S3OSInfo struct {
	// Configured S3 bucket name
	Bucket string `protobuf:"bytes,1,opt,name=bucket,proto3" json:"bucket,omitempty"`
	// Configured S3 region
	Region string `protobuf:"bytes,2,opt,name=region,proto3" json:"region,omitempty"`
	// POST policy that S3 owner node creates to give write access to other node.
	Policy string `protobuf:"bytes,3,opt,name=policy,proto3" json:"policy,omitempty"`
	// Signature for POST policy.
	Signature string `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature,omitempty"`
	// Needed for POST policy.
	XAmzCredential string `protobuf:"bytes,5,opt,name=xAmzCredential,proto3" json:"xAmzCredential,omitempty"`
	// Needed for POST policy.
	XAmzDate             string   `protobuf:"bytes,6,opt,name=xAmzDate,proto3" json:"xAmzDate,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S3OSInfo) Reset()         { *m = S3OSInfo{} }
func (m *S3OSInfo) String() string { return proto.CompactTextString(m) }
func (*S3OSInfo) ProtoMessage()    {}
func (*S3OSInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_lp_rpc_410c4c5f0e477d83, []int{2}
}
func (m *S3OSInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_S3OSInfo.Unmarshal(m, b)
}
func (m *S3OSInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_S3OSInfo.Marshal(b, m, deterministic)
}
func (dst *S3OSInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S3OSInfo.Merge(dst, src)
}
func (m *S3OSInfo) XXX_Size() int {
	return xxx_messageInfo_S3OSInfo.Size(m)
}
func (m *S3OSInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_S3OSInfo.DiscardUnknown(m)
}

var xxx_messageInfo_S3OSInfo proto.InternalMessageInfo

func (m *S3OSInfo) GetBucket() string {
	if m != nil {
		return m.Bucket
	}
	return ""
}

func (m *S3OSInfo) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *S3OSInfo) GetPolicy() string {
	if m != nil {
		return m.Policy
	}
	return ""
}

func (m *S3OSInfo) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

func (m *S3OSInfo) GetXAmzCredential() string {
	if m != nil {
		return m.XAmzCredential
	}
	return ""
}

func (m *S3OSInfo) GetXAmzDate() string {
	if m != nil {
		return m.XAmzDate
	}
	return ""
}

type SessionInfo struct {
	// nonce - unique identificator of video stream, used in folder name there data saved in storage
	// (folder name matters when transcoder puts trasncoded data into B's owned storage).
	Nonce                uint64   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	OsInfo               *OSInfo  `protobuf:"bytes,2,opt,name=osInfo,proto3" json:"osInfo,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SessionInfo) Reset()         { *m = SessionInfo{} }
func (m *SessionInfo) String() string { return proto.CompactTextString(m) }
func (*SessionInfo) ProtoMessage()    {}
func (*SessionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_lp_rpc_410c4c5f0e477d83, []int{3}
}
func (m *SessionInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SessionInfo.Unmarshal(m, b)
}
func (m *SessionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SessionInfo.Marshal(b, m, deterministic)
}
func (dst *SessionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionInfo.Merge(dst, src)
}
func (m *SessionInfo) XXX_Size() int {
	return xxx_messageInfo_SessionInfo.Size(m)
}
func (m *SessionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SessionInfo proto.InternalMessageInfo

func (m *SessionInfo) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *SessionInfo) GetOsInfo() *OSInfo {
	if m != nil {
		return m.OsInfo
	}
	return nil
}

// Used in POST /segment call to carry info about segment to transcode from broadcaster to transcoder
// Can contain credentials of OS where broadcaster wants transcoded data to be put.
type SegmentInfo struct {
	Turi                 *TypedURI    `protobuf:"bytes,1,opt,name=turi,proto3" json:"turi,omitempty"`
	SessionInfo          *SessionInfo `protobuf:"bytes,2,opt,name=sessionInfo,proto3" json:"sessionInfo,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *SegmentInfo) Reset()         { *m = SegmentInfo{} }
func (m *SegmentInfo) String() string { return proto.CompactTextString(m) }
func (*SegmentInfo) ProtoMessage()    {}
func (*SegmentInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_lp_rpc_410c4c5f0e477d83, []int{4}
}
func (m *SegmentInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SegmentInfo.Unmarshal(m, b)
}
func (m *SegmentInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SegmentInfo.Marshal(b, m, deterministic)
}
func (dst *SegmentInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SegmentInfo.Merge(dst, src)
}
func (m *SegmentInfo) XXX_Size() int {
	return xxx_messageInfo_SegmentInfo.Size(m)
}
func (m *SegmentInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SegmentInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SegmentInfo proto.InternalMessageInfo

func (m *SegmentInfo) GetTuri() *TypedURI {
	if m != nil {
		return m.Turi
	}
	return nil
}

func (m *SegmentInfo) GetSessionInfo() *SessionInfo {
	if m != nil {
		return m.SessionInfo
	}
	return nil
}

// The orchestrator sends this in response to `GetTranscoder`, containing the
// transcoder URI, associated credentials authorizing the broadcaster to
// use the transcoder, and miscellaneous data related to the job.
type TranscoderInfo struct {
	// URI of the transcoder to use for submitting segments.
	Transcoder string `protobuf:"bytes,1,opt,name=transcoder,proto3" json:"transcoder,omitempty"`
	// Signals the authentication method to expect within `credentials`. This
	// field is opaque to the broadcaster, and should be passed to the transcoder.
	AuthType string `protobuf:"bytes,2,opt,name=authType,proto3" json:"authType,omitempty"`
	// Credentials to verify the request has been authorized by an orchestrator.
	// This field is opaque to the broadcaster.
	Credentials string `protobuf:"bytes,3,opt,name=credentials,proto3" json:"credentials,omitempty"`
	// Transcoded streamId list to update the master manifest on the broadcaster.
	StreamIds map[string]string `protobuf:"bytes,16,rep,name=streamIds,proto3" json:"streamIds,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Orchestrator returns info about own input object storage, if it wants it to be used.
	PreferredIOS         *OSInfo  `protobuf:"bytes,32,opt,name=preferredIOS,proto3" json:"preferredIOS,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TranscoderInfo) Reset()         { *m = TranscoderInfo{} }
func (m *TranscoderInfo) String() string { return proto.CompactTextString(m) }
func (*TranscoderInfo) ProtoMessage()    {}
func (*TranscoderInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_lp_rpc_410c4c5f0e477d83, []int{5}
}
func (m *TranscoderInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TranscoderInfo.Unmarshal(m, b)
}
func (m *TranscoderInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TranscoderInfo.Marshal(b, m, deterministic)
}
func (dst *TranscoderInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TranscoderInfo.Merge(dst, src)
}
func (m *TranscoderInfo) XXX_Size() int {
	return xxx_messageInfo_TranscoderInfo.Size(m)
}
func (m *TranscoderInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TranscoderInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TranscoderInfo proto.InternalMessageInfo

func (m *TranscoderInfo) GetTranscoder() string {
	if m != nil {
		return m.Transcoder
	}
	return ""
}

func (m *TranscoderInfo) GetAuthType() string {
	if m != nil {
		return m.AuthType
	}
	return ""
}

func (m *TranscoderInfo) GetCredentials() string {
	if m != nil {
		return m.Credentials
	}
	return ""
}

func (m *TranscoderInfo) GetStreamIds() map[string]string {
	if m != nil {
		return m.StreamIds
	}
	return nil
}

func (m *TranscoderInfo) GetPreferredIOS() *OSInfo {
	if m != nil {
		return m.PreferredIOS
	}
	return nil
}

// AuthToken is sent by the orchestrator and encoded in the `credentials` field
// This record is opaque to the broadcaster and is only relevant between the
// orchestrator and the transcoder.
type AuthToken struct {
	// Signature of the orchestrator over the remaining fields
	Sig                  []byte   `protobuf:"bytes,1,opt,name=sig,proto3" json:"sig,omitempty"`
	JobId                int64    `protobuf:"varint,16,opt,name=jobId,proto3" json:"jobId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AuthToken) Reset()         { *m = AuthToken{} }
func (m *AuthToken) String() string { return proto.CompactTextString(m) }
func (*AuthToken) ProtoMessage()    {}
func (*AuthToken) Descriptor() ([]byte, []int) {
	return fileDescriptor_lp_rpc_410c4c5f0e477d83, []int{6}
}
func (m *AuthToken) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AuthToken.Unmarshal(m, b)
}
func (m *AuthToken) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AuthToken.Marshal(b, m, deterministic)
}
func (dst *AuthToken) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthToken.Merge(dst, src)
}
func (m *AuthToken) XXX_Size() int {
	return xxx_messageInfo_AuthToken.Size(m)
}
func (m *AuthToken) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthToken.DiscardUnknown(m)
}

var xxx_messageInfo_AuthToken proto.InternalMessageInfo

func (m *AuthToken) GetSig() []byte {
	if m != nil {
		return m.Sig
	}
	return nil
}

func (m *AuthToken) GetJobId() int64 {
	if m != nil {
		return m.JobId
	}
	return 0
}

// Data included by the broadcaster when submitting a segment for transcoding.
type SegData struct {
	// Sequence number of the segment to be transcoded
	Seq int64 `protobuf:"varint,1,opt,name=seq,proto3" json:"seq,omitempty"`
	// Hash of the segment data to be transcoded
	Hash []byte `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	// Broadcaster signature for the segment. Corresponds to:
	// broadcaster.sign(streamId | seqNo | dataHash)
	// where streamId is derived from the jobId
	Sig                  []byte   `protobuf:"bytes,3,opt,name=sig,proto3" json:"sig,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SegData) Reset()         { *m = SegData{} }
func (m *SegData) String() string { return proto.CompactTextString(m) }
func (*SegData) ProtoMessage()    {}
func (*SegData) Descriptor() ([]byte, []int) {
	return fileDescriptor_lp_rpc_410c4c5f0e477d83, []int{7}
}
func (m *SegData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SegData.Unmarshal(m, b)
}
func (m *SegData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SegData.Marshal(b, m, deterministic)
}
func (dst *SegData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SegData.Merge(dst, src)
}
func (m *SegData) XXX_Size() int {
	return xxx_messageInfo_SegData.Size(m)
}
func (m *SegData) XXX_DiscardUnknown() {
	xxx_messageInfo_SegData.DiscardUnknown(m)
}

var xxx_messageInfo_SegData proto.InternalMessageInfo

func (m *SegData) GetSeq() int64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *SegData) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *SegData) GetSig() []byte {
	if m != nil {
		return m.Sig
	}
	return nil
}

// Individual transcoded segment data.
type TranscodedSegmentData struct {
	// URL where the transcoded data can be downloaded from.
	Url                  string    `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	Turl                 *TypedURI `protobuf:"bytes,2,opt,name=turl,proto3" json:"turl,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *TranscodedSegmentData) Reset()         { *m = TranscodedSegmentData{} }
func (m *TranscodedSegmentData) String() string { return proto.CompactTextString(m) }
func (*TranscodedSegmentData) ProtoMessage()    {}
func (*TranscodedSegmentData) Descriptor() ([]byte, []int) {
	return fileDescriptor_lp_rpc_410c4c5f0e477d83, []int{8}
}
func (m *TranscodedSegmentData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TranscodedSegmentData.Unmarshal(m, b)
}
func (m *TranscodedSegmentData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TranscodedSegmentData.Marshal(b, m, deterministic)
}
func (dst *TranscodedSegmentData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TranscodedSegmentData.Merge(dst, src)
}
func (m *TranscodedSegmentData) XXX_Size() int {
	return xxx_messageInfo_TranscodedSegmentData.Size(m)
}
func (m *TranscodedSegmentData) XXX_DiscardUnknown() {
	xxx_messageInfo_TranscodedSegmentData.DiscardUnknown(m)
}

var xxx_messageInfo_TranscodedSegmentData proto.InternalMessageInfo

func (m *TranscodedSegmentData) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *TranscodedSegmentData) GetTurl() *TypedURI {
	if m != nil {
		return m.Turl
	}
	return nil
}

//
// TypedURI contains information needed to access segment written to specific storage.
// Plus it contains presentation of this segment in the manifest.
// Potentially it can contain credentials for reading data from storage
// (for now all we write should be public).
type TypedURI struct {
	// ipfs, s3, ...
	Storage string `protobuf:"bytes,1,opt,name=storage,proto3" json:"storage,omitempty"`
	// Can be specific to storage driver. For now local and S3 storages contails absolute URL,
	// ipfs contains just hash of file.
	Uri string `protobuf:"bytes,2,opt,name=uri,proto3" json:"uri,omitempty"`
	// URI to be placed in manifest
	// for IPFS it is always will be ipfs://hash
	// for others it can be absolute url or just segment's name.
	UriInManifest string `protobuf:"bytes,4,opt,name=uri_in_manifest,json=uriInManifest,proto3" json:"uri_in_manifest,omitempty"`
	// Name that will be put into 'Title' field of media playlist.
	Title                string   `protobuf:"bytes,5,opt,name=title,proto3" json:"title,omitempty"`
	SeqNo                uint64   `protobuf:"varint,7,opt,name=seqNo,proto3" json:"seqNo,omitempty"`
	StreamID             string   `protobuf:"bytes,8,opt,name=streamID,proto3" json:"streamID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TypedURI) Reset()         { *m = TypedURI{} }
func (m *TypedURI) String() string { return proto.CompactTextString(m) }
func (*TypedURI) ProtoMessage()    {}
func (*TypedURI) Descriptor() ([]byte, []int) {
	return fileDescriptor_lp_rpc_410c4c5f0e477d83, []int{9}
}
func (m *TypedURI) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TypedURI.Unmarshal(m, b)
}
func (m *TypedURI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TypedURI.Marshal(b, m, deterministic)
}
func (dst *TypedURI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TypedURI.Merge(dst, src)
}
func (m *TypedURI) XXX_Size() int {
	return xxx_messageInfo_TypedURI.Size(m)
}
func (m *TypedURI) XXX_DiscardUnknown() {
	xxx_messageInfo_TypedURI.DiscardUnknown(m)
}

var xxx_messageInfo_TypedURI proto.InternalMessageInfo

func (m *TypedURI) GetStorage() string {
	if m != nil {
		return m.Storage
	}
	return ""
}

func (m *TypedURI) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *TypedURI) GetUriInManifest() string {
	if m != nil {
		return m.UriInManifest
	}
	return ""
}

func (m *TypedURI) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *TypedURI) GetSeqNo() uint64 {
	if m != nil {
		return m.SeqNo
	}
	return 0
}

func (m *TypedURI) GetStreamID() string {
	if m != nil {
		return m.StreamID
	}
	return ""
}

// A set of transcoded segments following the profiles specified in the jo .
type TranscodeData struct {
	// Transcoded data, in the order specified in the job options
	Segments []*TranscodedSegmentData `protobuf:"bytes,1,rep,name=segments,proto3" json:"segments,omitempty"`
	// Signature of the hash of the concatenated hashes
	Sig                  []byte   `protobuf:"bytes,2,opt,name=sig,proto3" json:"sig,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TranscodeData) Reset()         { *m = TranscodeData{} }
func (m *TranscodeData) String() string { return proto.CompactTextString(m) }
func (*TranscodeData) ProtoMessage()    {}
func (*TranscodeData) Descriptor() ([]byte, []int) {
	return fileDescriptor_lp_rpc_410c4c5f0e477d83, []int{10}
}
func (m *TranscodeData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TranscodeData.Unmarshal(m, b)
}
func (m *TranscodeData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TranscodeData.Marshal(b, m, deterministic)
}
func (dst *TranscodeData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TranscodeData.Merge(dst, src)
}
func (m *TranscodeData) XXX_Size() int {
	return xxx_messageInfo_TranscodeData.Size(m)
}
func (m *TranscodeData) XXX_DiscardUnknown() {
	xxx_messageInfo_TranscodeData.DiscardUnknown(m)
}

var xxx_messageInfo_TranscodeData proto.InternalMessageInfo

func (m *TranscodeData) GetSegments() []*TranscodedSegmentData {
	if m != nil {
		return m.Segments
	}
	return nil
}

func (m *TranscodeData) GetSig() []byte {
	if m != nil {
		return m.Sig
	}
	return nil
}

// Response that a transcoder sends after transcoding a segment.
type TranscodeResult struct {
	// Sequence number of the transcoded results.
	Seq int64 `protobuf:"varint,1,opt,name=seq,proto3" json:"seq,omitempty"`
	// Result of transcoding can be an error, or successful with more info
	//
	// Types that are valid to be assigned to Result:
	//	*TranscodeResult_Error
	//	*TranscodeResult_Data
	Result               isTranscodeResult_Result `protobuf_oneof:"result"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *TranscodeResult) Reset()         { *m = TranscodeResult{} }
func (m *TranscodeResult) String() string { return proto.CompactTextString(m) }
func (*TranscodeResult) ProtoMessage()    {}
func (*TranscodeResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_lp_rpc_410c4c5f0e477d83, []int{11}
}
func (m *TranscodeResult) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TranscodeResult.Unmarshal(m, b)
}
func (m *TranscodeResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TranscodeResult.Marshal(b, m, deterministic)
}
func (dst *TranscodeResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TranscodeResult.Merge(dst, src)
}
func (m *TranscodeResult) XXX_Size() int {
	return xxx_messageInfo_TranscodeResult.Size(m)
}
func (m *TranscodeResult) XXX_DiscardUnknown() {
	xxx_messageInfo_TranscodeResult.DiscardUnknown(m)
}

var xxx_messageInfo_TranscodeResult proto.InternalMessageInfo

type isTranscodeResult_Result interface {
	isTranscodeResult_Result()
}

type TranscodeResult_Error struct {
	Error string `protobuf:"bytes,2,opt,name=error,proto3,oneof"`
}
type TranscodeResult_Data struct {
	Data *TranscodeData `protobuf:"bytes,3,opt,name=data,proto3,oneof"`
}

func (*TranscodeResult_Error) isTranscodeResult_Result() {}
func (*TranscodeResult_Data) isTranscodeResult_Result()  {}

func (m *TranscodeResult) GetResult() isTranscodeResult_Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *TranscodeResult) GetSeq() int64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *TranscodeResult) GetError() string {
	if x, ok := m.GetResult().(*TranscodeResult_Error); ok {
		return x.Error
	}
	return ""
}

func (m *TranscodeResult) GetData() *TranscodeData {
	if x, ok := m.GetResult().(*TranscodeResult_Data); ok {
		return x.Data
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TranscodeResult) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TranscodeResult_OneofMarshaler, _TranscodeResult_OneofUnmarshaler, _TranscodeResult_OneofSizer, []interface{}{
		(*TranscodeResult_Error)(nil),
		(*TranscodeResult_Data)(nil),
	}
}

func _TranscodeResult_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TranscodeResult)
	// result
	switch x := m.Result.(type) {
	case *TranscodeResult_Error:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Error)
	case *TranscodeResult_Data:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Data); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TranscodeResult.Result has unexpected type %T", x)
	}
	return nil
}

func _TranscodeResult_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TranscodeResult)
	switch tag {
	case 2: // result.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Result = &TranscodeResult_Error{x}
		return true, err
	case 3: // result.data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TranscodeData)
		err := b.DecodeMessage(msg)
		m.Result = &TranscodeResult_Data{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TranscodeResult_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TranscodeResult)
	// result
	switch x := m.Result.(type) {
	case *TranscodeResult_Error:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Error)))
		n += len(x.Error)
	case *TranscodeResult_Data:
		s := proto.Size(x.Data)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*TranscoderRequest)(nil), "net.TranscoderRequest")
	proto.RegisterType((*OSInfo)(nil), "net.OSInfo")
	proto.RegisterType((*S3OSInfo)(nil), "net.S3OSInfo")
	proto.RegisterType((*SessionInfo)(nil), "net.SessionInfo")
	proto.RegisterType((*SegmentInfo)(nil), "net.SegmentInfo")
	proto.RegisterType((*TranscoderInfo)(nil), "net.TranscoderInfo")
	proto.RegisterMapType((map[string]string)(nil), "net.TranscoderInfo.StreamIdsEntry")
	proto.RegisterType((*AuthToken)(nil), "net.AuthToken")
	proto.RegisterType((*SegData)(nil), "net.SegData")
	proto.RegisterType((*TranscodedSegmentData)(nil), "net.TranscodedSegmentData")
	proto.RegisterType((*TypedURI)(nil), "net.TypedURI")
	proto.RegisterType((*TranscodeData)(nil), "net.TranscodeData")
	proto.RegisterType((*TranscodeResult)(nil), "net.TranscodeResult")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// OrchestratorClient is the client API for Orchestrator service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type OrchestratorClient interface {
	// Called by the broadcaster to request transcoder info from an orchestrator.
	GetTranscoder(ctx context.Context, in *TranscoderRequest, opts ...grpc.CallOption) (*TranscoderInfo, error)
}

type orchestratorClient struct {
	cc *grpc.ClientConn
}

func NewOrchestratorClient(cc *grpc.ClientConn) OrchestratorClient {
	return &orchestratorClient{cc}
}

func (c *orchestratorClient) GetTranscoder(ctx context.Context, in *TranscoderRequest, opts ...grpc.CallOption) (*TranscoderInfo, error) {
	out := new(TranscoderInfo)
	err := c.cc.Invoke(ctx, "/net.Orchestrator/GetTranscoder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OrchestratorServer is the server API for Orchestrator service.
type OrchestratorServer interface {
	// Called by the broadcaster to request transcoder info from an orchestrator.
	GetTranscoder(context.Context, *TranscoderRequest) (*TranscoderInfo, error)
}

func RegisterOrchestratorServer(s *grpc.Server, srv OrchestratorServer) {
	s.RegisterService(&_Orchestrator_serviceDesc, srv)
}

func _Orchestrator_GetTranscoder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TranscoderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrchestratorServer).GetTranscoder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/net.Orchestrator/GetTranscoder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrchestratorServer).GetTranscoder(ctx, req.(*TranscoderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Orchestrator_serviceDesc = grpc.ServiceDesc{
	ServiceName: "net.Orchestrator",
	HandlerType: (*OrchestratorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTranscoder",
			Handler:    _Orchestrator_GetTranscoder_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "net/lp_rpc.proto",
}

func init() { proto.RegisterFile("net/lp_rpc.proto", fileDescriptor_lp_rpc_410c4c5f0e477d83) }

var fileDescriptor_lp_rpc_410c4c5f0e477d83 = []byte{
	// 714 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x54, 0x5d, 0x6f, 0x13, 0x3b,
	0x10, 0xed, 0x36, 0x1f, 0x4d, 0x66, 0x9b, 0x36, 0xd7, 0xb7, 0xb7, 0x5a, 0x45, 0x57, 0x57, 0xb9,
	0x8b, 0xa8, 0xf2, 0x94, 0x4a, 0x89, 0x84, 0x10, 0xf4, 0x81, 0x42, 0x11, 0x8d, 0x54, 0xa8, 0xb4,
	0x29, 0x0f, 0x3c, 0x55, 0x6e, 0x76, 0x92, 0x2c, 0xdd, 0xd8, 0xa9, 0xed, 0x45, 0x84, 0x3f, 0xc3,
	0x1b, 0xbf, 0x80, 0x1f, 0x88, 0xfc, 0xb1, 0xbb, 0x49, 0x89, 0x78, 0xf3, 0x39, 0x1e, 0x8f, 0x3d,
	0x67, 0xce, 0x18, 0xda, 0x0c, 0xd5, 0x69, 0xba, 0xbc, 0x15, 0xcb, 0x49, 0x7f, 0x29, 0xb8, 0xe2,
	0xa4, 0xc2, 0x50, 0x85, 0x2f, 0xe1, 0xaf, 0x1b, 0x41, 0x99, 0x9c, 0xf0, 0x18, 0x45, 0x84, 0x0f,
	0x19, 0x4a, 0x45, 0x8e, 0xa0, 0xf6, 0x99, 0xdf, 0x8d, 0xe2, 0xc0, 0xeb, 0x7a, 0xbd, 0x4a, 0x64,
	0x01, 0x69, 0x43, 0x45, 0x26, 0xb3, 0x60, 0xb7, 0xeb, 0xf5, 0xf6, 0x23, 0xbd, 0x0c, 0x47, 0x50,
	0xbf, 0x1e, 0x8f, 0xd8, 0x94, 0x93, 0x00, 0xf6, 0xa4, 0xe2, 0x82, 0xce, 0xd0, 0x9c, 0x69, 0x46,
	0x39, 0x24, 0x4f, 0xa1, 0x2e, 0x87, 0x09, 0x9b, 0xf2, 0xa0, 0xdd, 0xf5, 0x7a, 0xfe, 0xa0, 0xd5,
	0x67, 0xa8, 0xfa, 0xe3, 0xa1, 0x3d, 0x18, 0xb9, 0xcd, 0xf0, 0xa7, 0x07, 0x8d, 0x9c, 0x24, 0xc7,
	0x50, 0xbf, 0xcb, 0x26, 0xf7, 0xa8, 0x5c, 0x32, 0x87, 0x34, 0x2f, 0x70, 0x96, 0x70, 0x66, 0x1e,
	0xd1, 0x8c, 0x1c, 0xd2, 0xfc, 0x92, 0xa7, 0xc9, 0x64, 0x15, 0x54, 0x2c, 0x6f, 0x11, 0xf9, 0x17,
	0x9a, 0x32, 0x99, 0x31, 0xaa, 0x32, 0x81, 0x41, 0xd5, 0x6c, 0x95, 0x04, 0x39, 0x81, 0x83, 0xaf,
	0xe7, 0x8b, 0x6f, 0x6f, 0x04, 0xc6, 0xc8, 0x54, 0x42, 0xd3, 0xa0, 0x66, 0x42, 0x1e, 0xb1, 0xa4,
	0x03, 0x0d, 0xcd, 0x5c, 0x50, 0x85, 0x41, 0xdd, 0x44, 0x14, 0x38, 0xbc, 0x04, 0x7f, 0x8c, 0x52,
	0x26, 0x9c, 0x99, 0x87, 0x1f, 0x41, 0x8d, 0x71, 0x36, 0xb1, 0x22, 0x54, 0x23, 0x0b, 0xc8, 0x13,
	0xa8, 0x73, 0xa9, 0xf7, 0xcd, 0xb3, 0xfd, 0x81, 0x6f, 0x24, 0xc8, 0x05, 0xb0, 0x5b, 0x61, 0xac,
	0x33, 0xcd, 0x16, 0xc8, 0x94, 0xc9, 0xf4, 0x3f, 0x54, 0x55, 0x26, 0x12, 0x93, 0x28, 0x17, 0xed,
	0x66, 0xb5, 0xc4, 0xf8, 0x63, 0x34, 0x8a, 0xcc, 0x16, 0x19, 0x80, 0x2f, 0xcb, 0xbb, 0x5d, 0xee,
	0xb6, 0x95, 0xb7, 0xe4, 0xa3, 0xf5, 0xa0, 0xf0, 0xfb, 0x2e, 0x1c, 0x94, 0xfd, 0x36, 0x37, 0xfd,
	0x07, 0xa0, 0x0a, 0xc6, 0x09, 0xbe, 0xc6, 0xe8, 0xf2, 0x69, 0xa6, 0xe6, 0xfa, 0x72, 0x27, 0x7b,
	0x81, 0x49, 0x17, 0xfc, 0x49, 0x21, 0x94, 0x74, 0xea, 0xaf, 0x53, 0xe4, 0x15, 0x34, 0xa5, 0x12,
	0x48, 0x17, 0xa3, 0x58, 0x06, 0xed, 0x6e, 0xa5, 0xe7, 0x0f, 0x42, 0x5b, 0xcc, 0xc6, 0x2b, 0xfa,
	0xe3, 0x3c, 0xe8, 0x2d, 0x53, 0x62, 0x15, 0x95, 0x87, 0xc8, 0x29, 0xec, 0x2f, 0x05, 0x4e, 0x51,
	0x08, 0x8c, 0x47, 0xd7, 0xe3, 0xa0, 0xfb, 0xbb, 0x86, 0x1b, 0x01, 0x9d, 0x33, 0x38, 0xd8, 0xcc,
	0xa6, 0x9d, 0x7b, 0x8f, 0x2b, 0x57, 0x9b, 0x5e, 0xea, 0x46, 0x7d, 0xa1, 0x69, 0x96, 0x57, 0x64,
	0xc1, 0x8b, 0xdd, 0xe7, 0x5e, 0x38, 0x84, 0xe6, 0xb9, 0x2e, 0x8f, 0xdf, 0x23, 0xcb, 0x2d, 0xef,
	0x15, 0x96, 0x2f, 0x47, 0xa3, 0xbd, 0x36, 0x1a, 0xe1, 0x39, 0xec, 0x8d, 0x71, 0x76, 0x41, 0x15,
	0x35, 0x47, 0xf0, 0xc1, 0x4d, 0x8e, 0x5e, 0x12, 0x02, 0xd5, 0x39, 0x95, 0x73, 0x37, 0x38, 0x66,
	0x9d, 0x27, 0xae, 0x94, 0xb3, 0x74, 0x05, 0xff, 0x14, 0x92, 0xc4, 0xce, 0x09, 0x79, 0xc2, 0x4c,
	0xa4, 0xf9, 0xe3, 0x33, 0x91, 0x3a, 0x6f, 0xa4, 0xae, 0xe3, 0x5b, 0xbc, 0x91, 0x86, 0x3f, 0x3c,
	0x68, 0xe4, 0xd4, 0x1f, 0x86, 0xd3, 0xe4, 0x4e, 0x9c, 0x08, 0x7a, 0x49, 0x4e, 0xe0, 0x30, 0x13,
	0xc9, 0x6d, 0xc2, 0x6e, 0x17, 0x94, 0x25, 0x53, 0x94, 0xca, 0x0d, 0x4e, 0x2b, 0x13, 0xc9, 0x88,
	0xbd, 0x77, 0xa4, 0xd6, 0x41, 0x25, 0x2a, 0x45, 0x37, 0x33, 0x16, 0x68, 0x56, 0xe2, 0xc3, 0x07,
	0x1e, 0xec, 0x59, 0xff, 0x1b, 0xa0, 0x1d, 0xe4, 0xda, 0x79, 0x11, 0x34, 0xac, 0x83, 0x72, 0x1c,
	0x7e, 0x82, 0x56, 0x51, 0xb6, 0x29, 0xf7, 0x19, 0x34, 0xa4, 0xad, 0x5e, 0x06, 0x9e, 0xf1, 0x4b,
	0x67, 0xd3, 0x2f, 0xeb, 0xe2, 0x44, 0x45, 0xec, 0x96, 0xdf, 0x89, 0xc3, 0x61, 0x71, 0x28, 0x42,
	0x99, 0xa5, 0x6a, 0x4b, 0x73, 0x8e, 0xa1, 0x86, 0x42, 0x70, 0x61, 0x35, 0xb8, 0xdc, 0x89, 0x2c,
	0x24, 0x3d, 0xa8, 0xc6, 0x54, 0x51, 0xd3, 0x21, 0x7f, 0x40, 0x36, 0x9f, 0xa0, 0xaf, 0xbe, 0xdc,
	0x89, 0x4c, 0xc4, 0xeb, 0x86, 0xfe, 0x94, 0x74, 0xf6, 0xc1, 0x15, 0xec, 0x5f, 0x8b, 0xc9, 0x1c,
	0xa5, 0x12, 0x54, 0x71, 0x41, 0xce, 0xa0, 0xf5, 0x0e, 0x55, 0x69, 0x74, 0x72, 0xfc, 0xc8, 0xf9,
	0xee, 0xbf, 0xed, 0xfc, 0xbd, 0x65, 0x22, 0xee, 0xea, 0xe6, 0x97, 0x1e, 0xfe, 0x0a, 0x00, 0x00,
	0xff, 0xff, 0x42, 0xd1, 0xa5, 0x97, 0xb9, 0x05, 0x00, 0x00,
}
